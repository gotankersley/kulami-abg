function drawLine(ctx, x1, y1, x2, y2) {
	ctx.beginPath();
	ctx.moveTo(x1,y1);
	ctx.lineTo(x2,y2);    
    ctx.closePath();	
	ctx.stroke();   
}

function drawCircle(ctx, x, y, r, margin) {
	ctx.beginPath();    
	ctx.arc(x + r,y + r, r - margin, 0, 2 * Math.PI, true);
	ctx.closePath();    
	ctx.fill();		
}


function drawRoundedRect(ctx, x, y, w, h, r) {
	//http://stackoverflow.com/questions/1255512/how-to-draw-a-rounded-rectangle-on-html-canvas
	if (w < 2 * r) r = w / 2;
	if (h < 2 * r) r = h / 2;
	ctx.beginPath();
	ctx.moveTo(x+r, y);
	ctx.arcTo(x+w, y,   x+w, y+h, r);
	ctx.arcTo(x+w, y+h, x,   y+h, r);
	ctx.arcTo(x,   y+h, x,   y,   r);
	ctx.arcTo(x,   y,   x+w, y,   r);
	ctx.closePath();	
	ctx.fill();		
}
/* Note: This uses Javascript typed arrays to emulate 64 bit integers, and to do bitwise operations with them */
var MASK_TO_BIT = {1:0,2:1,4:2,8:3,16:4,32:5,64:6,128:7,256:8,512:9,1024:10,2048:11,4096:12,8192:13,16384:14,32768:15,65536:16,131072:17,262144:18,524288:19,1048576:20,2097152:21,4194304:22,8388608:23,16777216:24,33554432:25,67108864:26,134217728:27,268435456:28,536870912:29,1073741824:30,2147483648:31};

function set(bb, off, val) {
	bb[off] = val[0];
	bb[off+1] = val[1];
}
function get(bb, off) {
	var n = new Uint32Array([
		bb[off],
		bb[off+1]
	]);
	return n;
}

function eq(x, y) {
	if (x[0] == y[0] && x[1] == y[1]) return true;
	else return false;
}

function and(x, y) { 
	var n = new Uint32Array([
		x[0] & y[0],
		x[1] & y[1]
	]);
	return n;
}

function or(x, y) { 
	var n = new Uint32Array([
		x[0] | y[0],
		x[1] | y[1]
	]);
	return n;
}

function xor(x, y) { 
	var n = new Uint32Array([
		x[0] ^ y[0],
		x[1] ^ y[1]
	]);
	return n;
}

function xorEq(x, y) { // ^=	
	x[0] ^= y[0];
	x[1] ^= y[1];
}

function xorEqOff(bb, off, y) {
	bb[off] ^= y[0];
	bb[off+1] ^= y[1];
}

function bitCount(x) {
	var lo = x[0];
	lo = lo - ((lo >>> 1) & 0x55555555);
	lo = (lo & 0x33333333) + ((lo >>> 2) & 0x33333333);
	var loCount = ((((lo + (lo >>> 4)) & 0x0F0F0F0F) * 0x01010101) >>> 24);
	
	var hi = x[1];
	hi = hi - ((hi >>> 1) & 0x55555555);
	hi = (hi & 0x33333333) + ((hi >>> 2) & 0x33333333);
	return loCount + ((((hi + (hi >>> 4)) & 0x0F0F0F0F) * 0x01010101) >>> 24);	
}

function bitScan(x){
	var bits = [];
	var lo = x[0];
	while (lo) {
		var minBit = lo & -lo;
		bits.push(MASK_TO_BIT[minBit >>> 0]);
		lo &= lo-1;
	}
	
	var hi = x[1];
	while (hi) {
		var minBit = hi & -hi;
		bits.push(MASK_TO_BIT[minBit >>> 0] + 32);
		hi &= hi-1;
	}	
	return bits;
}

var GRID_SIZE = 10;
var BOARD_SIZE = 64;
var PINS_SIZE = 56;
var PINS_PER_PLAYER = 28;

var TILES_SIZE = 18; 
var TILE_EMPTY = 0;

var PIN_EMPTY = 0;
var PIN_PLAYER1 = 1;
var PIN_PLAYER2 = 2;
var PIN_LAST1 = 3;
var PIN_LAST2 = 4;

var ASCII_A = 65;
var ASCII_0 = 48;

var TURN_PLAYER1 = 0;
var TURN_PLAYER2 = 1;
var INVALID = -1;

var WIN = 1;
var LOSE = -1;
var TIE = 0;
var defaultBoardStr = 
	'B0B0C0D0D0D0E0E0A0A0' +
	'B0B0C0F0F0G0E0E0A0A0' +
	'H0H0C0F0F0G0E0E0A0A0' +
	'H0H0I0I0I0J0J0J0A0A0' +
	'K0K0I0I0I0L0L0M0A0A0' +
	'N0O0O0P0P0L0L0M0A0A0' +
	'N0O0O0Q0Q0Q0R0R0A0A0' +
	'N0O0O0Q0Q0Q0R0R0A0A0' +
	'A0A0A0A0A0A0A0A0A0A0' +
	'A0A0A0A0A0A0A0A0A0A0';

var irrBoardStr = 
	'A0A0A0A0B0B0A0A0A0A0' +
	'A0A0C0C0B0B0D0A0A0A0' +
	'E0E0C0C0F0F0D0A0A0A0' +
	'E0E0G0H0H0H0D0I0I0I0' +
	'E0E0G0H0H0H0J0J0J0A0' +
	'K0K0G0L0L0L0J0J0J0A0' +
	'A0A0M0M0N0O0O0P0P0A0' +
	'A0A0M0M0N0O0O0P0P0A0' +
	'A0A0A0Q0Q0R0R0P0P0A0' +
	'A0A0A0A0A0R0R0A0A0A0';

var KBNS = [
	"B0B0C0D0D0D0E0E0A0A0B0B0C0F0F0G0E0E0A0A0H0H0C0F0F0G0E0E0A0A0H0H0I0I0I0J0J0J0A0A0K0K0I0I0I0L0L0M0A0A0N0O0O0P0P0L0L0M0A0A0N0O0O0Q0Q0Q0R0R0A0A0N0O0O0Q0Q0Q0R0R0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0", //default
	"A0A0A0A0B0B0A0A0A0A0A0A0C0C0B0B0D0A0A0A0E0E0C0C0F0F0D0A0A0A0E0E0G0H0H0H0D0I0I0I0E0E0G0H0H0H0J0J0J0A0K0K0G0L0L0L0J0J0J0A0A0A0M0M0N0O0O0P0P0A0A0A0M0M0N0O0O0P0P0A0A0A0A0Q0Q0R0R0P0P0A0A0A0A0A0A0R0R0A0A0A0", //irreg
	"B0B0B0C0C0D0D0D0A0A0E0E0E0C0C0D0D0D0A0A0F0G0G0H0H0I0I0I0A0A0F0J0J0H0H0I0I0I0A0A0F0K0K0L0L0M0M0M0A0A0N0O0O0L0L0M0M0M0A0A0N0P0P0Q0Q0R0R0R0A0A0N0P0P0Q0Q0R0R0R0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0",
	"B0C0C0C0D0D0E0E0A0A0B0C0C0C0D0D0E0E0A0A0B0F0G0G0H0H0E0E0A0A0I0F0J0J0H0H0K0K0A0A0I0F0L0L0M0M0K0K0A0A0N0O0O0O0M0M0K0K0A0A0N0P0P0P0Q0Q0R0R0A0A0N0P0P0P0Q0Q0R0R0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0",
	"B0C0C0D0D0E0E0E0A0A0B0C0C0F0F0E0E0E0A0A0G0G0G0F0F0H0H0I0A0A0J0J0K0K0K0H0H0I0A0A0J0J0K0K0K0L0L0I0A0A0M0M0M0N0N0O0P0P0A0A0Q0Q0Q0R0R0O0P0P0A0A0Q0Q0Q0R0R0O0P0P0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0",
	"B0B0B0C0D0D0E0E0A0A0B0B0B0C0D0D0E0E0A0A0F0G0G0C0H0H0E0E0A0A0F0G0G0I0H0H0J0K0A0A0L0L0L0I0M0M0J0K0A0A0L0L0L0N0M0M0J0O0A0A0P0P0Q0N0R0R0R0O0A0A0P0P0Q0N0R0R0R0O0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0",
	"B0B0B0C0C0C0D0D0A0A0E0E0F0F0G0G0D0D0A0A0E0E0H0H0G0G0I0I0A0A0J0J0H0H0K0K0I0I0A0A0L0L0L0M0K0K0I0I0A0A0L0L0L0M0K0K0N0N0A0A0O0O0P0M0Q0Q0N0N0A0A0O0O0P0R0R0R0N0N0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0",
	"B0B0B0C0C0D0D0E0A0A0F0G0G0C0C0H0H0E0A0A0F0G0G0C0C0H0H0E0A0A0I0I0I0J0J0K0K0K0A0A0I0I0I0J0J0K0K0K0A0A0L0M0M0N0N0O0O0P0A0A0L0M0M0N0N0O0O0P0A0A0L0Q0Q0N0N0R0R0R0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0",
	"B0B0C0C0C0D0E0E0A0A0B0B0C0C0C0D0F0F0A0A0G0G0H0I0I0D0F0F0A0A0G0G0H0I0I0J0J0J0A0A0G0G0K0K0K0J0J0J0A0A0L0L0M0M0N0O0P0P0A0A0Q0Q0M0M0N0O0R0R0A0A0Q0Q0M0M0N0O0R0R0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0",
];
	
//Class Board
function Board(boardStr) {
	this.tiles = new Array(GRID_SIZE);
	this.pins = new Array(GRID_SIZE);
	this.turn = TURN_PLAYER1;
	this.last1 = {r: INVALID, c: INVALID};
	this.last2 = {r: INVALID, c: INVALID};	
	this.pinCount1 = 0;	
	this.pinCount2 = 0;
	
	for (var i = 0; i < GRID_SIZE; i++) {
		this.tiles[i] = new Array(GRID_SIZE);
		this.pins[i] = new Array(GRID_SIZE);
	}
	
	//Load board
	if (typeof (boardStr) != 'undefined') this.loadFromString(boardStr);	
	else this.loadFromString(defaultBoardStr);	
}

Board.prototype.copy = function() {
	var newBoard = new Board();
	newBoard.pinCount1 = this.pinCount1;
	newBoard.pinCount2 = this.pinCount2;
	newBoard.last1.r = this.last1.r;
	newBoard.last1.c = this.last1.c;
	newBoard.last2.r = this.last2.r;
	newBoard.last2.c = this.last2.c;
	newBoard.turn = this.turn;
	for (var r = 0; r < GRID_SIZE; r++) {
		for (var c = 0; c < GRID_SIZE; c++) {
			newBoard.tiles[r][c] = this.tiles[r][c];
			newBoard.pins[r][c] = this.pins[r][c];
		}
	}
	return newBoard;
}


Board.prototype.loadFromString = function(boardStr) {
	boardStr = boardStr.toUpperCase();
	var p = 0;
	for (var i = 0; i < 2 * (GRID_SIZE * GRID_SIZE); i+= 2) {
		var r = Math.floor(p / GRID_SIZE);
		var c = Math.floor(p % GRID_SIZE);
		
		//Tile char
		var tileChar = boardStr.charAt(i);
		var tile = parseInt(-(ASCII_A - tileChar.charCodeAt(0)));
		if (tile < TILE_EMPTY || tile >= TILES_SIZE) { 
			alert('Error parsing tile "' + tileChar + '": ' + boardStr);
			return false;
		}
		this.tiles[r][c] = tile;
		
		//Pin char
		var pinChar = boardStr.charAt(i+1);
		var pin = parseInt(-(ASCII_0 - pinChar.charCodeAt(0)));
		if (pin < PIN_EMPTY || pin > PIN_LAST2) {
			alert('Error parsing pin: "' + pinChar + '": ' + boardStr);
			return false;
		}
		else if (pin == PIN_LAST1) {
			this.pins[r][c] = PIN_PLAYER1;
			this.last1 = {r:r, c:c};
		}
		else if (pin == PIN_LAST2) {
			this.pins[r][c] = PIN_PLAYER2;
			this.last2 = {r:r, c:c};
		}
		else this.pins[r][c] = pin;
		p++;		
	}
	return true;
}

Board.prototype.toString = function() {
	var boardStr = '';
	for (var r = 0; r < GRID_SIZE; r++) {
		for (var c = 0; c < GRID_SIZE; c++) {
			boardStr += String.fromCharCode(ASCII_A + this.tiles[r][c]);
			if (r == this.last1.r && c == this.last1.c) boardStr += String.fromCharCode(ASCII_0 + PIN_LAST1);
			else if (r == this.last2.r && c == this.last2.c) boardStr += String.fromCharCode(ASCII_0 + PIN_LAST2);			
			else boardStr += String.fromCharCode(ASCII_0 + this.pins[r][c]);
		}
	}	
	return boardStr;
}

Board.prototype.isValid = function(r, c) {
	if (this.pinCount1 + this.pinCount2 >= PINS_SIZE) return false; //Out of pins - each player gets 28
	else if (r < 0 || r >= GRID_SIZE || c < 0 || c >= GRID_SIZE) return false; //Out of 10x10 bounds
	else if (this.tiles[r][c] == TILE_EMPTY) return false; //Not on a tile
	else if (this.pins[r][c] != PIN_EMPTY) return false; //There is already a pin in the space
	else if (this.last1.r == INVALID) return true; //First move can play anywhere

	//Additional rules for after the first move
	var last = (this.turn == TURN_PLAYER1)? this.last1 : this.last2;
	var oppLast = (this.turn == TURN_PLAYER1)? this.last2 : this.last1;
		
	if (r != oppLast.r && c != oppLast.c) return false; //Rule 1 - Have to play on either the x, or y axes of opponent's last move
	else if (this.tiles[r][c] == this.tiles[oppLast.r][oppLast.c]) return false; //Rule 2 - Can't play in same tile that contains opponent's last move
	else if (last.r == INVALID) return true; //On the second move, player 2 doesn't have a last move, and so Rule 3 doesn't apply
	else if (this.tiles[r][c] == this.tiles[last.r][last.c]) return false; //Rule 3 - Can't play in same tile that contains player's last move	
	else return true;
}

Board.prototype.isGameOver = function() {
	
	if (this.pinCount1 + this.pinCount2 >= PINS_SIZE) return true; //Out of pins to play
	else if (this.getMoves().length == 0) return true; //No moves available 
	else return false;
}

Board.prototype.getMoves = function() {
	var moves = [];
	//First move - any valid tile can be chosen
	if (this.last1.r == INVALID) { 
		for (var r = 0; r < GRID_SIZE; r++) {
			for (var c = 0; c < GRID_SIZE; c++) {
				if (this.tiles[r][c] != TILE_EMPTY) moves.push({r: r, c: c});
			}
		}
	}
	else { //After the first move
		var last = (this.turn == TURN_PLAYER1)? this.last1 : this.last2;
		var lastTile = (last.r == INVALID)? INVALID : this.tiles[last.r][last.c];
		var oppLast = (this.turn == TURN_PLAYER1)? this.last2 : this.last1;
		var oppLastTile = this.tiles[oppLast.r][oppLast.c];
		for (var i = 0; i < GRID_SIZE; i++) {
			//Y-axis moves
			var tileR = this.tiles[oppLast.r][i];			
			if (this.pins[oppLast.r][i] == PIN_EMPTY && //empty space
				tileR != TILE_EMPTY && //On tile							
				tileR != oppLastTile && //Not in same tile where opponent last moved
				tileR != lastTile //Not in the same tile where player last moved
			) {
				moves.push({r:oppLast.r, c:i});
			}
			
			//X-axis moves
			var tileC = this.tiles[i][oppLast.c];
			if (this.pins[i][oppLast.c] == PIN_EMPTY && //empty space
				tileC != TILE_EMPTY && //On tile							
				tileC != oppLastTile && //Not in same tile where opponent last moved
				tileC != lastTile //Not in the same tile where player last moved
			) {
				moves.push({r:i, c:oppLast.c});
			}		
		}
	
	}
	return moves;
}

Board.prototype.score = function() {
	var tiles1 = new Array(TILES_SIZE);
	var tiles2 = new Array(TILES_SIZE);
	var tileCounts = new Array(TILES_SIZE);
	
	for (var t = 1; t < TILES_SIZE; t++) {
		tiles1[t] = 0;
		tiles2[t] = 0;
		tileCounts[t] = 0;
	}
	
	for (var r = 0; r < GRID_SIZE; r++) {
		for (var c = 0; c < GRID_SIZE; c++) {
			var tile = this.tiles[r][c];
			if (tile == TILE_EMPTY) continue;
			if (this.pins[r][c] == PIN_PLAYER1) tiles1[tile]++;
			else if (this.pins[r][c] == PIN_PLAYER2) tiles2[tile]++;
			tileCounts[tile]++;
		}
	}
	
	var score = {p1:0, p2:0};
	for (var t = 1; t < TILES_SIZE; t++) {		
		if (tiles1[t] > tiles2[t]) score.p1 += tileCounts[t];
		else if (tiles2[t] > tiles1[t]) score.p2 += tileCounts[t];
	}
	return score;
}

Board.prototype.makeMove = function(r, c) {	
	//Place pin
	if (this.turn == TURN_PLAYER1) { 
		this.pins[r][c] = PIN_PLAYER1;
		this.last1 = {r: r, c: c}; //Update last		
		this.pinCount1++; 
	}
	else { //Player 2
		this.pins[r][c] = PIN_PLAYER2;
		this.last2 = {r: r, c: c}; //Update last
		this.pinCount2++;
	}	
	
	this.turn = !this.turn; //Change turn
}

//End class Board
	
//BB is a bitboard implementation which uses javascript's typed arrays to emulate 64 bit integers
//Constants
//var GRID_SIZE = 10;
//var BOARD_SIZE = 64;
//var TILES_SIZE = 18; //Includes empty tile
var BB_INVALID = 0xffffffff;
var SCORE_OFFSET = 100;


//Enums 
var P1 = 0; var P2 = 2; 
var P1_LO = 0; var P1_HI = 1; var P2_LO = 2; var P2_HI = 3; var LAST1 = 4; var LAST2 = 5; var TURN = 6; var SCORE = 7;

//Masks
var EMPTY = new Uint32Array([0,0]);
var FULL = new Uint32Array([0xffffffff, 0xffffffff]);

//Global conversion arrays
var MPOS = new Array(BOARD_SIZE); //Mask position
var POS = new Array(BOARD_SIZE); 
var ROW = new Array(BOARD_SIZE);
var COL = new Array(BOARD_SIZE);
var MOVES = new Array(BOARD_SIZE);

var TILES_BY_POS = new Array(BOARD_SIZE); //Indexed by pos
var TILES_BY_ID = new Array(TILES_SIZE); //Indexed by tileId
var TILE_IDS_BY_POS = new Array(BOARD_SIZE); 
var TILE_COUNTS_BY_POS = new Array(BOARD_SIZE);
var TILE_COUNTS_BY_ID = new Array(TILES_SIZE);

//Struct BB
function BB_new() {
	var bb = new Uint32Array([
		0, 			//p1 lo
		0, 			//p1 hi
		0, 			//p2 lo
		0, 			//p2 hi
		BB_INVALID, 	//last1
		BB_INVALID,	//last2
		TURN_PLAYER1,//turn
		0			//score
	]);
	return bb;
}

function BB_initConstants() {
	for (var i = 0; i < GRID_SIZE; i++) {		
		POS[i] = new Array(GRID_SIZE);				
	}
	
	for (var i = 0; i < BOARD_SIZE; i++) {
		MPOS[i] = (i < 32)? new Uint32Array([1 << i, 0]) : new Uint32Array([0, 1 << i]);
	}	
}

function BB_calcScore(bb) {
	//NOTE: Global scoring is where Player1 points are positive, Tie is 0, and Player2 points are negative.
	//However, score is stored in an uint, and can't be negative, so scoring is offset by + 100.	
	//ALSO NOTE: This is used for initialization, but the score is also incrementally calculated 
	//in the makeMove function which is faster
	var globalScore = SCORE_OFFSET;
	var p1 = get(bb, P1);
	var p2 = get(bb, P2);
	for (var t = 1; t < TILES_SIZE; t++) {
		var tileCount1 = bitCount(and(TILES_BY_ID[t], p1));
		var tileCount2 = bitCount(and(TILES_BY_ID[t], p2));
		if (tileCount1 > tileCount2) globalScore += TILE_COUNTS_BY_ID[t];
		else if (tileCount2 > tileCount1) globalScore -= TILE_COUNTS_BY_ID[t];
	}
	return globalScore;
}

function BB_fromKBN(bb, kbn) { //bb passed by reference
	kbn = kbn.toUpperCase();
	var KBN_LENGTH = 2 * (GRID_SIZE * GRID_SIZE);
	if (kbn.length != KBN_LENGTH) {
		var msg = 'Invalid kbn length "' + kbn.length + '", expected ' + KBN_LENGTH;
		return {status:false, msg:msg};
	}
	//Convert to 2D grid
	var p = 0;
	var nonEmptyPos = 0;
	var tiles = new Array(GRID_SIZE);
	var pins = new Array(GRID_SIZE);		
	
	//Clunky j/s array initialization
	for (var i = 0; i < GRID_SIZE; i++) {
		tiles[i] = new Array(GRID_SIZE);
		pins[i] = new Array(GRID_SIZE);			
	}
		
	for (var i = 0; i < TILES_SIZE; i++) {
		TILES_BY_ID[i] = new Uint32Array(2);
	}
	
	for (var i = 0; i < KBN_LENGTH; i+= 2) {
		var r = Math.floor(p / GRID_SIZE);
		var c = Math.floor(p % GRID_SIZE);
		
		//Tile char
		var tileChar = kbn.charAt(i);
		var tile = parseInt(-(ASCII_A - tileChar.charCodeAt(0)));
		if (tile < TILE_EMPTY || tile >= TILES_SIZE) {
			var msg = 'Invalid tile code "' + tileChar + '" in kbn:' + i + ', expected A-R';
			return {status:false, msg:msg};
		}					
		else tiles[r][c] = tile;
		
		//Pin char
		var pinChar = kbn.charAt(i+1);
		var pin = parseInt(-(ASCII_0 - pinChar.charCodeAt(0)));
		if (pin < PIN_EMPTY || pin > PIN_LAST2) {
			var msg = 'Invalid pin code "' + pinChar + '" in kbn:' + i + ', expected 0-4';
			return {status:false, msg:msg};			
		}
		else pins[r][c] = pin;		

		//Pos mapping - from row,col (10x10) -> pos (64)
		if (tile == TILE_EMPTY) POS[r][c] = INVALID; //Empty tile
		else { //Non-empty tile
			ROW[nonEmptyPos] = r;
			COL[nonEmptyPos] = c;
			POS[r][c] = nonEmptyPos;
			nonEmptyPos++;
		}
		p++;		
	}
	
	//Convert to bitboard
	var p1 = new Uint32Array(2);
	var p2 = new Uint32Array(2);
	bb[LAST1] = BB_INVALID;
	bb[LAST2] = BB_INVALID;
	for (var r = 0; r < GRID_SIZE; r++) {
		for (var c = 0; c < GRID_SIZE; c++) {
			if (tiles[r][c] == TILE_EMPTY) continue;
			var pos = POS[r][c];
			var mpos = MPOS[pos];
			
			//Tiles
			var tileId = tiles[r][c];			
			xorEq(TILES_BY_ID[tileId], mpos);
			
			//Pins
			if (pins[r][c] == PIN_EMPTY) continue;
			var pin = pins[r][c];
			if (pin == PIN_PLAYER1) xorEq(p1, mpos);
			else if (pin == PIN_PLAYER2) xorEq(p2, mpos);
			else if (pin == PIN_LAST1) bb[LAST1] = pos;
			else if (pin == PIN_LAST2) bb[LAST2] = pos;
		}
	
	}
	//Add lasts
	if (bb[LAST1] != BB_INVALID) xorEq(p1, MPOS[bb[LAST1]]);
	if (bb[LAST2] != BB_INVALID) xorEq(p2, MPOS[bb[LAST2]]);
	set(bb, P1, p1);
	set(bb, P2, p2);
	
	//Distribute tile masks - and generate move masks
	for (p = 0; p < BOARD_SIZE; p++) {
		var r = ROW[p];
		var c = COL[p];
		
		//Tiles
		var tileId = tiles[r][c];
		TILE_IDS_BY_POS[p] = tileId;
		TILES_BY_POS[p] = TILES_BY_ID[tileId];		
		
		//Move masks		
		MOVES[p] = new Uint32Array(2);
		for (var i = 0; i < GRID_SIZE; i++) {						
			if (POS[r][i] != INVALID) xorEq(MOVES[p], MPOS[POS[r][i]]); //x-axis
			if (POS[i][c] != INVALID) xorEq(MOVES[p], MPOS[POS[i][c]]); //y-axis			
		}		
	}
	
	//Get tile counts - used for scoring
	for (var t = 1; t < TILES_SIZE; t++) { //Start at 1 to ignore EMPTY_TILE
		TILE_COUNTS_BY_ID[t] = bitCount(TILES_BY_ID[t]);
	}

	for (p = 0; p < BOARD_SIZE; p++) {
		var tileId = TILE_IDS_BY_POS[p];
		TILE_COUNTS_BY_POS[p] = TILE_COUNTS_BY_ID[tileId];
	}
	
	//Turn - inferred from pin count: even sum will be player1's turn, odd will be player2's 
	bb[TURN] = bitCount(or(p1, p2)) % 2;
	
	bb[SCORE] = BB_calcScore(bb);
	
	return {status:true, msg:''};
}

function BB_toKBN(bb) {
	var kbn = '';	
	
	var p1 = get(bb, P1);
	var p2 = get(bb, P2);	
		
	//Convert to 2D array				
	for (var r = 0; r < GRID_SIZE; r++) {
		
		for (var c = 0; c < GRID_SIZE; c++) {
			var pos = POS[r][c];
			//Empty tile
			if (pos == INVALID) {
				kbn += 'A0';
				continue;				
			}
			
			//Tile code	
			var tileId = TILE_IDS_BY_POS[pos];
			kbn += String.fromCharCode(ASCII_A + tileId);
			
			//Pins	
			var mpos = MPOS[pos];
			if (pos == bb[LAST1]) kbn += String.fromCharCode(ASCII_0 + PIN_LAST1);
			else if (pos == bb[LAST2]) kbn += String.fromCharCode(ASCII_0 + PIN_LAST2);
			else if (eq(and(p1, mpos), mpos)) kbn += String.fromCharCode(ASCII_0 + PIN_PLAYER1);
			else if (eq(and(p2, mpos), mpos)) kbn += String.fromCharCode(ASCII_0 + PIN_PLAYER2);
			else kbn += '0';
		}
	}
	return kbn;
}

function BB_makeMove(bb, pos) {
	var p1 = get(bb, P1);
	var p2 = get(bb, P2);
	
	var turnCount1 = bitCount(and(p1, TILES_BY_POS[pos])); 
	var turnCount2 = bitCount(and(p2, TILES_BY_POS[pos]));
	
	if (bb[TURN] == TURN_PLAYER1) {
		xorEqOff(bb, P1, MPOS[pos]);
		bb[LAST1] = pos;
		
		//Incremental scoring for player 1
		turnCount1++;
		if (Math.abs(turnCount1 - turnCount2) <= 1) { //If either player has a difference of more than 1 it won't make a difference
			if (turnCount1 >= turnCount2) bb[SCORE] += TILE_COUNTS_BY_POS[pos]; //Only pin on tile, or going from tie to majority, or making a tie				
		}
	}
	else { //Player 2
		xorEqOff(bb, P2, MPOS[pos]);		
		bb[LAST2] = pos;
		
		//Incremental scoring for player 1
		turnCount2++;
		if (Math.abs(turnCount2 - turnCount1) <= 1) { //If either player has a difference of more than 1 it won't make a difference
			if (turnCount2 >= turnCount1) bb[SCORE] -= TILE_COUNTS_BY_POS[pos]; //Only pin on tile, or going from tie to majority, or making a tie				
		}
	}
	
	//Change turn
	bb[TURN] = !bb[TURN];
}

function BB_getMoves(bb) { //Returns mask
	//First move in game - player can play anywhere
	if (bb[LAST1] == BB_INVALID) return FULL;
			
	var last = bb[LAST1];
	var oppLast = bb[LAST2];
	if (bb[TURN] == TURN_PLAYER2) {
		last = bb[LAST2];
		oppLast = bb[LAST1];
	}	
	var p1 = get(bb, P1);
	var p2 = get(bb, P2);
	
	var moves = new Uint32Array(MOVES[oppLast]); //Rule 1 - Add moves on the x, and y axes from opponent's last pin
	xorEq(moves, and(moves, or(p1, p2))); //Rule 0 - Don't place where there is already a pin
	xorEq(moves, and(moves, TILES_BY_POS[oppLast])); //Rule 2 - Subtract pins that intersect opponent's last tile, and opponent's pins
	if (last != BB_INVALID) xorEq(moves, and(moves, TILES_BY_POS[last])); //Rule 3 - Subtract pins that intersect player's last tile
	return moves;
}

function BB_getFirstAvailMove(bb) {
	var moves = bitScan(BB_getMoves(bb));	
	return moves[0];
}

function BB_getRandomMove(bb) {
	var moves = bitScan(BB_getMoves(bb));	
	return moves[Math.floor(Math.random() * moves.length)];
}

function BB_getLastPos(bb) {
	if (bb[TURN] == TURN_PLAYER1) return bb[LAST2];
	else return bb[LAST1];
}

function BB_getLastMove(bb) {
	if (bb[TURN] == TURN_PLAYER1) return {r:ROW[bb[LAST2]], c:COL[bb[LAST2]]};
	else return {r:ROW[bb[LAST1]], c:COL[bb[LAST1]]};
}

function BB_getWinMove(bb) {
	var moves = bitScan(BB_getMoves(bb));	
	for (var m = 0; m < moves.length; m++) {		
		var kidBoard = new Uint32Array(bb);
		BB_makeMove(kidBoard, moves[m]);
		var kidMoves = BB_getMoves(kidBoard);
		if (eq(kidMoves, EMPTY)) {
			if (bb[TURN] == TURN_PLAYER1) {
				if (kidBoard[SCORE] > SCORE_OFFSET) return moves[m];
			}
			else {
				if (kidBoard[SCORE] < SCORE_OFFSET ) return moves[m];
			}				
		}		
	}
	return false;
}


function BB_print(bb) {
	var p1 = get(bb, P1);
	var p2 = get(bb, P2);
	console.log('P1', bitScan(p1));
	console.log('P2', bitScan(p2));
}

function BB_simulate(bbRoot) {
	
	//Scoring is local	
	var bb = new Uint32Array(bbRoot); //Copy, because root is passed by reference	
	var p1 = get(bb, P1);	
	var p2 = get(bb, P2);
	
	var moveCount = bitCount(or(p1, p2));
	for (var i = 0; i < (PINS_SIZE - moveCount); i++) { //Play until out of pins
		var moveMask = BB_getMoves(bb);
		if (eq(moveMask, EMPTY)) break; //Out of moves

		//Make move	- Check for wins
		var moves = bitScan(moveMask);
		/*var nonTerminal = [];
		for (var m = 0; m < moves.length; m++) {
			
			var kidBoard = new Uint32Array(bb);
			BB_makeMove(kidBoard, moves[m]);
			var kidMoves = BB_getMoves(kidBoard);
			if (eq(kidMoves, EMPTY)) {
				if (bb[TURN] == bbRoot[TURN]) {
					if (kidBoard[SCORE] > SCORE_OFFSET && bbRoot[TURN] == TURN_PLAYER1) return WIN;
					else if (kidBoard[SCORE] < SCORE_OFFSET && bbRoot[TURN] == TURN_PLAYER2) return WIN;
				}
			}
			else nonTerminal.push(moves[m]);
		}
		if (nonTerminal.length == 0) return LOSE;*/
		//Make random non-terminal move
		//BB_makeMove(bb, nonTerminal[Math.floor(Math.random() * nonTerminal.length)]);
		
		BB_makeMove(bb, moves[Math.floor(Math.random() * moves.length)]);
	}
	if (bb[SCORE] > SCORE_OFFSET) return (bbRoot[TURN] == TURN_PLAYER1)? WIN : LOSE;
	else if (bb[SCORE] < SCORE_OFFSET) return (bbRoot[TURN] == TURN_PLAYER2)? WIN : LOSE;
	else return TIE;
}

/*function BB_getNonTerminalMoves(bb) { //Does not include win, loss, or ties
	var moves = bitScan(BB_getMoves(bb));
	var nonTerminal = [];
	for (var i = 0; i < moves.length; i++) {
		var kid = new Uint32Array(bb);
		var kidMoves = BB_getMoves(kid);
		if (!eq(kidMoves, EMPTY)) nonTerminal.push(moves[i]);
	}
	return nonTerminal;
}*/

//End struct BB

var PLAYER_HUMAN = 0;
var PLAYER_RANDOM = 1;
var PLAYER_HEURISTIC = 2;
var PLAYER_EM = 3;
var PLAYER_AB = 4;
var PLAYER_MC = 5;
var PLAYER_BB = 6;
var PLAYER_ALPHA = 7;


//Class Players 
function Players(playerType1, playerType2) {	
	//BB_initConstants();	
	this.player1 = (typeof(playerType1) != 'undefined')? playerType1 : PLAYER_HUMAN;
	this.player2 = (typeof(playerType2) != 'undefined')? playerType2 : PLAYER_HUMAN;	
}

Players.prototype.getCurrent = function(board) {
	if (board.turn == TURN_PLAYER1) return this.player1;
	else return this.player2;	
}

Players.prototype.getMove = function(board, onPlayed) {
	for (var r = 0; r < GRID_SIZE; r++) {
		for (var c = 0; c < GRID_SIZE; c++) {
			game.scoreMap[r][c] = '';
		}
	}
	var player = this.getCurrent(board);
	//Handle no-move, and one move
	var moves = board.getMoves();
	if (moves.length == 0) onPlayed({r:INVALID, c:INVALID});
	else if (moves.length == 1) onPlayed(moves[0]);
	
	//Async
	else if (player == PLAYER_BB) {
		
		MC.getMove(board, onPlayed);
	}
	
	//Sync
	else {
		var move;
		//Random
		if (player == PLAYER_RANDOM) move = this.getRandom(board);				
		
		//Heuristic
		else if (player == PLAYER_HEURISTIC) move = this.getHeuristic(board);
		
		//Native
		else if (player == PLAYER_AB) move = this.getNative(board, 'ab');		
		else if (player == PLAYER_MC) move = this.getNative(board, 'mc');		
		
		//EM
		else if (player == PLAYER_EM) move = this.getEm(board);	
		
		//AB
		else if (player == PLAYER_ALPHA) move = AB.getMove(board);
		
		else move = {r:INVALID, c:INVALID};
		onPlayed(move); //Callback
	}	
	
}

//Moves types for different players
Players.prototype.getEm = function (board) {
	var result = Module.ccall('getMove', 'number', [], []); 
	var moveR = result & 0xff;
	var moveC = (result & 0xff00) >> 8;
	return {r:moveR, c:moveC};
}

Players.prototype.getNative = function (board, engineType) {
    var move = {r: INVALID, c:INVALID};
	var url = '/ai?board=' + board.toString() + '&engine=' + engineType;
	$.ajax({
		url:url ,			 
		success: function(moveStr) {			
			if (moveStr == 0) {
				alert('no moves available');
			}
			else if (moveStr.length > 2) {
				alert('Invalid moveStr: ' + moveStr);
			}			
			else {				
				move.c = parseInt(-(ASCII_A - moveStr.charCodeAt(0)));
				move.r = parseInt(-(ASCII_0 - moveStr.charCodeAt(1)));								
			}
		},
		async: false
    });   
	return move;
}

Players.prototype.getRandom = function(board) {
	var moves = board.getMoves();	
	if (moves.length == 0) return {r: INVALID, c:INVALID};	
	else return moves[Math.floor(Math.random() * moves.length)];
}


Players.prototype.getHeuristic = function(board) {
	var moves = board.getMoves();
	var bestScore = INVALID;
	var bestMove;
	var curTurn = (board.turn == TURN_PLAYER1)? TURN_PLAYER1 : TURN_PLAYER2;
	for (var i = 0; i < moves.length; i++) {
		var tmpBoard = board.copy();
		tmpBoard.makeMove(moves[i].r, moves[i].c);
		var scores = tmpBoard.score();
		var score = (curTurn == TURN_PLAYER1)? scores.p1 : scores.p2;
		if (menu.showScoreMap) game.scoreMap[moves[i].r][moves[i].c] = score;			
		if (score > bestScore) {
			bestScore = score;
			bestMove = i;
		}		
	}
	
	return moves[bestMove];
}
//End class Players

//Struct MenuProperties
function MenuProperties() {
	this.showAxes = true;
	this.showGrid = false;
	this.showPinsRemaining = true;
	this.showScore = true;
	this.showScoreMap = false;
	this.suggest = suggestMove;
	this.moveDelay = 0;
	this.tileRounding = TILE_RADIUS_SIZE;
	this.board = 0;
	this.player1 = PLAYER_HUMAN;
	this.player2 = PLAYER_HUMAN;
}
//End struct MenuProperties

//Class MenuManager
function MenuManager() {
	this.properties = new MenuProperties();
	this.rootMenu = new dat.GUI();	
	
	//Options
	var optionsMenu = this.rootMenu.addFolder('Options');
	optionsMenu.add(this.properties, 'moveDelay', 0, 10000);	
	optionsMenu.add(this.properties, 'tileRounding', 0, UNIT_SIZE);	
	optionsMenu.add(this.properties, 'showAxes');
	optionsMenu.add(this.properties, 'showGrid');
	optionsMenu.add(this.properties, 'showPinsRemaining');
	optionsMenu.add(this.properties, 'showScore').onChange(this.onScoreToggle);
	optionsMenu.add(this.properties, 'showScoreMap');
	optionsMenu.add(this.properties, 'suggest');	
	
	//Root menu
	var boardOptions = {Default:0, Irregular:1, Team1:2, Team2:3, Team3:4, Team4:5, Team5:6, Team6:7, Team7:8};
	this.rootMenu.add(this.properties, 'board', boardOptions).onChange(this.onBoardChange);

	var playerOptions = {Human:PLAYER_HUMAN, Weak:PLAYER_HEURISTIC, Medium:PLAYER_BB, Good:PLAYER_ALPHA};
	this.rootMenu.add(this.properties, 'player1', playerOptions).onChange(this.onChangePlayer);
	this.rootMenu.add(this.properties, 'player2', playerOptions).onChange(this.onChangePlayer);
}

//Events
MenuManager.prototype.onChangePlayer = function(val) {
	game.players = new Players(menu.player1, menu.player2);	
	game.onMoveStart();
}

MenuManager.prototype.onBoardChange = function(val) {
	game = new Game(KBNS[val]);
}

MenuManager.prototype.onScoreToggle = function(val) {
	$('#score').toggle();
}

function suggestMove() {
	menu.showScoreMap = true;
	for (var r = 0; r < GRID_SIZE; r++) {
		for (var c = 0; c < GRID_SIZE; c++) {
			game.scoreMap[r][c] = '';
		}
	}
	AB.getMove(game.board);	
}
//End class MenuManager
//Constants
var CANVAS_SIZE = 800;
var UNIT_SIZE = CANVAS_SIZE / GRID_SIZE;
var HALF_UNIT = UNIT_SIZE / 2;
var QUARTER_UNIT = UNIT_SIZE / 4;
var TILE_RADIUS_SIZE = 20;
var TILE_MARGIN_SIZE = 4;
var PIN_HOLE_SIZE = UNIT_SIZE / 6;
var PIN_RADIUS_SIZE = UNIT_SIZE / 3;

//Colors
var COLOR_BLACK = '#000';
var COLOR_TILE_EDGE = '#493d26';
var COLOR_AXES = '#a9a9f5';
var COLOR_CURSOR = '#7C6741';
var COLOR_P1 = '#f00';
var COLOR_P2 = '#303030';
var COLOR_P1_EDGE = '#600';
var COLOR_P2_EDGE = '#000';
var COLOR_TILE = '#deb887';	
var COLOR_TILE_DISABLED = '#8E775A';


//Class Game
function Game(boardStr) {
	//Init board - Convert tile cells to rectangle shapes for easier drawing
	this.board = new Board(boardStr);
	this.tileShapes = new Array(TILES_SIZE);
	this.scoreMap = new Array(GRID_SIZE);
	for (var r = 0; r < GRID_SIZE; r++) {
		var y = r * UNIT_SIZE;
		this.scoreMap[r] = new Array(GRID_SIZE);
		for (var c = 0; c < GRID_SIZE; c++) {
			this.scoreMap[r][c] = '';
			var x = c * UNIT_SIZE;
			var tile = this.board.tiles[r][c];
			var shape = this.tileShapes[tile];
			if (tile == TILE_EMPTY) continue;
			//See if this is the first time this tile has been seen
			else if (typeof(shape) == 'undefined') this.tileShapes[tile] = {x:x + TILE_MARGIN_SIZE, y:y + TILE_MARGIN_SIZE, w:0, h:0};
			else { //Update the width, and height dimensions
				this.tileShapes[tile].w = Math.max(shape.w, (x - shape.x + UNIT_SIZE) - TILE_MARGIN_SIZE);
				this.tileShapes[tile].h = Math.max(shape.h, (y - shape.y + UNIT_SIZE) - TILE_MARGIN_SIZE);
			}                                                                         
		}
	}
	
	//Players
	this.players = new Players(PLAYER_HUMAN, PLAYER_HUMAN);			
	
	this.cursorR = 0;
	this.cursorC = 0;
	
	var canvas = document.getElementById('mainCanvas');
	var pinCanvas = document.getElementById('pinCanvas');
	
	this.ctx = canvas.getContext('2d');    
	this.pinCtx = pinCanvas.getContext('2d');       
	
	this.ctx.font = "20px Georgia";
	this.draw();
}

//Game logic
Game.prototype.onMoveStart = function(r, c) {
	if (this.board.isGameOver()) return;
	
	if (this.players.getCurrent(this.board) != PLAYER_HUMAN) {
		this.players.getMove(this.board, function(move) {		
			game.onMakeMove(move.r, move.c);				
		});
	}	
}

Game.prototype.onMakeMove = function(r, c) {
	
	if (this.board.isValid(r, c)) {
		this.board.makeMove(r, c);			
		this.onMoveMade(r, c);
	}
	else this.onInvalidMove(r, c);
	
}

Game.prototype.onMoveMade = function(r, c) {
	//Update pin counts	
	var score = this.board.score();
	$('#score').text(score.p1 + ' - ' + score.p2);
	
	if (this.board.isGameOver()) this.onGameOver();
	else {
		$('#turn').attr('class', 'turn' + (this.board.turn + 1)); //Change turn			
		if (this.players.getCurrent(this.board) != PLAYER_HUMAN) {
			setTimeout(function() { //Give draw enough time to display board
				game.onMoveStart(); 
			}, menu.moveDelay + 10);
		}
	}
}

Game.prototype.onInvalidMove = function(r, c) {
	console.log('Invalid move: ', r, c);
	alert('Invalid move: ' + r + ',' + c);
}

Game.prototype.onGameOver = function() {
	var score = this.board.score();
	var noMoves = (this.board.pinCount1 + this.board.pinCount2 < PINS_SIZE)? 'No moves - ' : '';
	var msg;
	var winClass;
	if (score.p1 > score.p2) {
		msg = noMoves + 'Red WINS!!';
		winClass = 'win1';
	}
	else if (score.p2 > score.p1) {
		msg = noMoves + 'Black WINS!!';
		winClass = 'win2';
	}
	else {
		msg = noMoves + 'Tie score!';
		winClass = 'tie';
	}
	
	$('#turn').attr('class', winClass);
	$('#turn').text(msg);
	alert(msg);
}


//Event functions
Game.prototype.onClick = function(e) {
	
	var x,y;
	if(e.offsetX == undefined) { //Required for FF
		x = e.pageX - $('#mainCanvas').offset().left;
		y = e.pageY - $('#mainCanvas').offset().top; 
	}
	else {
		x = e.offsetX; 
		y = e.offsetY; 
	}	
	
	var r = Math.floor(y / UNIT_SIZE);
	var c = Math.floor(x / UNIT_SIZE);
	
	//Make sure in bounds
	if (game.players.getCurrent(game.board) == PLAYER_HUMAN) {
		if (r >= 0 && r < GRID_SIZE && c >= 0 && c < GRID_SIZE && game.board.tiles[r][c] != TILE_EMPTY) {
			if (game.board.isValid(r, c)) {
				game.board.makeMove(r, c);
				game.onMoveMade(r, c);
			}
			else game.onInvalidMove(r, c); 
		}
	}
	
}

Game.prototype.onMouse = function(e) {
	var x,y;
	if(e.offsetX == undefined) { //Required for FF
		x = e.pageX - $('#mainCanvas').offset().left;
		y = e.pageY - $('#mainCanvas').offset().top; 
	}
	else {
		x = e.offsetX; 
		y = e.offsetY; 
	}	
	
	game.cursorR = Math.floor(y / UNIT_SIZE);
	game.cursorC = Math.floor(x / UNIT_SIZE);
}

//Draw functions
Game.prototype.draw = function() {	
	var board = this.board;
	var last = board.last1;
	var oppLast = board.last2;
	if (board.turn == TURN_PLAYER2) {		
		last = board.last2;
		oppLast = board.last1;
	}
	var oppLastX = oppLast.c * UNIT_SIZE;
	var oppLastY = oppLast.r * UNIT_SIZE;
	var lastX = last.c * UNIT_SIZE;
	var lastY = last.r * UNIT_SIZE;
		
	//Clear canvases
	var ctx = this.ctx;
	ctx.clearRect(0,0, CANVAS_SIZE, CANVAS_SIZE);		
	var pinCtx = this.pinCtx;
	pinCtx.clearRect(0,0, 200, CANVAS_SIZE);
	
	var gridLength = GRID_SIZE * UNIT_SIZE;	
	
	
	//Tiles background
	ctx.lineWidth = 5;	
	for (var t = 1; t < TILES_SIZE; t++) {			
		var shape = this.tileShapes[t];
		if (oppLast.r == INVALID) ctx.fillStyle = COLOR_TILE;
		else if (oppLastX + HALF_UNIT >= shape.x && oppLastX <= (shape.x + shape.w) &&
			oppLastY + HALF_UNIT >= shape.y && oppLastY <= (shape.y + shape.h)) ctx.fillStyle = COLOR_TILE_DISABLED;					
		else if (lastX + HALF_UNIT >= shape.x && lastX <= (shape.x + shape.w) &&
			lastY + HALF_UNIT >= shape.y && lastY <= (shape.y + shape.h)) ctx.fillStyle = COLOR_TILE_DISABLED;					
		else ctx.fillStyle = COLOR_TILE;
		
		drawRoundedRect(ctx, shape.x, shape.y, shape.w, shape.h, menu.tileRounding); //Draw background		
		ctx.strokeStyle = COLOR_TILE_EDGE;
		ctx.stroke();				
	}
	
	
		
	//Axes lines
	if (menu.showAxes) {
		if (oppLast.r != INVALID) {		
			ctx.strokeStyle = COLOR_AXES;
					
			var axisY = oppLastY + HALF_UNIT;
			var axisX = oppLastX + HALF_UNIT;
			drawLine(ctx, 0, axisY, gridLength, axisY);
			drawLine(ctx, axisX, 0, axisX, gridLength);
		}
	}
	
	
	//Pins and holes
	var pinHoleMargin = HALF_UNIT - PIN_HOLE_SIZE;
	var pinMargin = HALF_UNIT - PIN_RADIUS_SIZE;
	for (var r = 0; r < GRID_SIZE; r++) {
		var y = r * UNIT_SIZE;
		for (var c = 0; c < GRID_SIZE; c++) {
			var x = c * UNIT_SIZE;
			var tile = board.tiles[r][c];
			var pin = board.pins[r][c];
			
			//Empty tile - used to mask axes lines
			if (tile == TILE_EMPTY) { 
				ctx.fillStyle = '#fff';
				ctx.fillRect(x, y, UNIT_SIZE, UNIT_SIZE);				
			}					
			
			//Pin
			else if (pin != PIN_EMPTY) {								
				if (pin == PIN_PLAYER1) {
					ctx.fillStyle = COLOR_P1;
					ctx.strokeStyle = COLOR_P1_EDGE;
				}
				else if (pin == PIN_PLAYER2) {
					ctx.fillStyle = COLOR_P2;			
					ctx.strokeStyle = COLOR_P2_EDGE;
				}
				drawCircle(ctx, x + pinMargin, y + pinMargin, PIN_RADIUS_SIZE, 0);	
				ctx.lineWidth = 2;
				ctx.stroke();
			}
			
			//Cursor
			else if (r == this.cursorR && c == this.cursorC) {
				var cursorX = this.cursorC * UNIT_SIZE;
				var cursorY = this.cursorR * UNIT_SIZE;							
				ctx.fillStyle = (board.turn == TURN_PLAYER1)? COLOR_P1 : COLOR_P2;
				drawCircle(ctx, x + pinHoleMargin - 5, y + pinHoleMargin - 5, PIN_HOLE_SIZE + 5, 0);
			}
			
			//Empty pin hole
			else { 
				ctx.fillStyle = COLOR_TILE_EDGE;
				drawCircle(ctx, x + pinHoleMargin, y + pinHoleMargin, PIN_HOLE_SIZE, 0);
			}
			
		}
	}
		
	
	
	//Grid	
	if (menu.showGrid) {
		ctx.lineWidth = 1;	
		ctx.strokeStyle = COLOR_BLACK;
		for (var i = 0; i < GRID_SIZE; i++) {
			var unit = i * UNIT_SIZE;
			drawLine(ctx, unit, 0, unit, gridLength); //Horizontal
			drawLine(ctx, 0, unit, gridLength, unit); //Vertical
		}
	}
	
	//Pins Remaining
	if (menu.showPinsRemaining) {	
		//Player 1's remaining pins
		pinCtx.fillStyle = COLOR_P1;
		for (var i = 0; i < PINS_PER_PLAYER - board.pinCount1; i++) 
		{
			var r = Math.floor(i / 4);
			var c = i % 4;		
			var x = 2 * (PIN_HOLE_SIZE + 1) * c;							
			var y = 2 * (PIN_HOLE_SIZE + 1) * r;			
			drawCircle(pinCtx, x, y + 50, PIN_HOLE_SIZE, 0);				
		}
		
		//Player 2's remaining pins
		pinCtx.fillStyle = COLOR_P2;
		for (var i = board.pinCount2; i < PINS_PER_PLAYER; i++) 
		{
			var r = Math.floor(i / 4);
			var c = i % 4;		
			var x = 2 * (PIN_HOLE_SIZE + 1) * c;							
			var y = 2 * (PIN_HOLE_SIZE + 1) * r;			
			drawCircle(pinCtx, x, y + 350, PIN_HOLE_SIZE, 0);				
		}
	}
	
	//Score map
	if (menu.showScoreMap) {
		for (var r = 0; r < GRID_SIZE; r++) {
			var y = ((r + 1) * UNIT_SIZE) - (QUARTER_UNIT) + 5;
			for (var c = 0; c < GRID_SIZE; c++) {
				var x = (c * UNIT_SIZE) + QUARTER_UNIT;
				if (this.board.tiles[r][c] == TILE_EMPTY) continue;
				var s = this.scoreMap[r][c];
				if (s == 100000) ctx.fillText('Win', x, y); 
				else if (s == -100000) ctx.fillText('Loss', x, y);
				else ctx.fillText(this.scoreMap[r][c], x, y); 
			}
		}		
	}
	
    requestAnimationFrame(this.draw.bind(this));
}

//End class Game
//Namespace MC
var MC = new function() {
	
	var MAX_ITERATIONS = 100000;
	var MAX_TIME_MS = 5000;
	var INFINITY = 100000;
	var MAX_THREADS = 8;
		
	this.finishedCount = 0;
	this.onPlayed;
	this.scores = [];
	this.bb;
	//this.iter;
	//Multi-threaded via web-workers
	this.getMove = function(board, onPlayed) {
		//this.iter = 0;
		this.finishedCount = 0;
		this.scores = [];
		
		//Init bitboard
		BB_initConstants();
		this.bb = BB_new();
		var res = BB_fromKBN(this.bb, board.toString());
		if (!res.status) {
			alert(res.msg);
			onPlayed({r:INVALID, c:INVALID});
		}		
		
		//Check for winning move
		var winMove = BB_getWinMove(this.bb);
		if (winMove !== false) {			
			onPlayed({r:ROW[winMove], c:COL[winMove]});
			return;
		}
				
		
		//Setup workers
		this.onPlayed = onPlayed;
		var workers = [];
		for (var i = 0; i < MAX_THREADS; i++) {
			
			var worker = new Worker('js/mc-worker.js');
			worker.onmessage = onWorkerFinished;
			workers.push(worker);
			var data = {id: i, kbn:board.toString(), maxIterations:MAX_ITERATIONS, maxTime:MAX_TIME_MS};			
			worker.postMessage(data); //Start thread
		}				
	}
	
	var onWorkerFinished = function(e) {
		var data = e.data;		
		//MC.iter += data.iter;
		var kidScores = data.scores;		
		var kidCount = kidScores.length;
		//First
		if (MC.finishedCount == 0) {
			for (var i = 0; i < kidCount; i++) {
				MC.scores.push(0);
			}
		}
		for (var i = 0; i < kidCount; i++) {
			MC.scores[i] += kidScores[i]; //Combine each worker's scores
			
		}
		MC.finishedCount++;
		
		//Last worker finished
		if (MC.finishedCount == MAX_THREADS) {
			//console.log('Iterations', MC.iter);
			//console.log(MC.scores);
			//Get best
			var bestScore = -INFINITY;
			var bestMove;
			for (var k = 0; k < kidCount; k++) {
				if (menu.showScoreMap) {					
					var r = ROW[data.moves[k]];
					var c = COL[data.moves[k]];
					game.scoreMap[r][c] = MC.scores[k];
				}
				if (MC.scores[k] > bestScore) {
					bestScore = MC.scores[k];
					bestMove = k;
				}
			}
			
			//Play chosen move
			if (bestScore != -INFINITY) { 
				var pos = data.moves[bestMove];				
				MC.onPlayed({r:ROW[pos], c:COL[pos]});				
			}
			else { //All moves lead to loss			
				var pos = BB_getFirstAvailMove(MC.bb);
				MC.onPlayed({r:ROW[pos], c:COL[pos]});
			}
			
		}

	}
			
}
//End namespace MC
var AB = new function() {
	var MAX_DEPTH = 10;
	var INFINITY = 100000;
	
	var bestMoveAtDepth = [];
	var compare = function(a, b) {
		if (a[TURN] == TURN_PLAYER1) return a[SCORE] - b[SCORE];
		else return b[SCORE] - a[SCORE];
	}	
	
	this.getMove = function(board) {
		
		//Init bitboard		
		BB_initConstants();	
		bb = BB_new();
		var res = BB_fromKBN(bb, board.toString());
		var moveCount = bitCount(or(bb, get(bb, P2)));
		if (moveCount == 0) MAX_DEPTH = 8;
		else if (moveCount <= 4) MAX_DEPTH = 10;
		else MAX_DEPTH = 12;
		
		//Alpha beta driver
		bestMoveAtDepth = new Array(MAX_DEPTH);
		var bestScore = negamax(bb, -INFINITY, INFINITY, 0);		
		var bestMove = bestMoveAtDepth[0];

		if (bestScore == -INFINITY) {
			var pos = BB_getFirstAvailMove(bb);
			return {r:ROW[pos], c:COL[pos]};
		}
		else return {r:ROW[bestMove], c:COL[bestMove]};
	}
	
	var negamax = function(bb, alpha, beta, depth) {
		
		//Anchor
		if (depth >= MAX_DEPTH) { //Max depth
			if (bb[TURN] == TURN_PLAYER1) return bb[SCORE] - SCORE_OFFSET;
			else return -(bb[SCORE] - SCORE_OFFSET); //Convert from global score to minmax score
		}
		
		var moveMask = BB_getMoves(bb);
				
		if (eq(moveMask, EMPTY)) { //No moves - Game over - return winner
			if (bb[SCORE] == SCORE_OFFSET) return 0;
			else if (bb[TURN] == TURN_PLAYER1) return (bb[SCORE] > SCORE_OFFSET)? INFINITY : -INFINITY;
			else return (bb[SCORE] < SCORE_OFFSET)? INFINITY : -INFINITY;
		}
		
		//Move ordering - to help AB achieve its full potential 
		var moves = bitScan(moveMask);
		var kids = [];		
		for (var i = 0; i < moves.length; i++) {
			var kidBoard = new Uint32Array(bb);
			BB_makeMove(kidBoard, moves[i]);
			kids.push(kidBoard);			
		}
		
		kids.sort(compare);		
		
		//Loop through sorted moves
		bestMoveAtDepth[depth] = INVALID;	
		var bestScore = -INFINITY;
		
		for (var i = 0; i < kids.length; i++) {		
			var kid = kids[i];
			//Recurse
			var recursedScore = negamax(kid, -beta, -Math.max(alpha, bestScore), depth+1);
			var currentScore = -recursedScore;
			if (menu.showScoreMap && depth == 0) { //Score map
				var p = (kid[TURN] == TURN_PLAYER1)? kid[LAST2] : kid[LAST1];
				game.scoreMap[ROW[p]][COL[p]] = currentScore; 			
			}
			if (currentScore > bestScore) {
				bestScore = currentScore;
				bestMoveAtDepth[depth] = (kid[TURN] == TURN_PLAYER1)? kid[LAST2] : kid[LAST1];

				if (bestScore >= beta) return bestScore; //AB cutoff			
			}					
		}
		return bestScore;	
	}
	
}